#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include "utils.h"
#include <cassert>
#include <cmath>

/*Задача 1
Что нужно сделать:
Вам даётся массив целых чисел. Необходимо найти такие два индекса i и j в этом массиве,
что сумма a[i], a[i+1], a[i+2], … a[j] будет максимально возможной и вывести их.
a = {-2,1,-3,4,-1,2,1,-5,4}
Тогда наибольшая сумма последовательных элементов находится
между индексами 3 и 6: {4,-1,2,1}, сумма = 6. Необходимо вывести 3 и 6.*/

void task7_1() {

  std::vector<int> a = { -2,1,-3,4,-1,2,1,-5,4 };
  int max_sum = a[0];
  int min_index = 0, max_index = 0;

  // Первое решение  O(n2)
    //for (int i = 0; i < a.size(); ++i) {
    //  int temp = a[i];
    //  for (int j = i + 1; j < a.size(); ++j) {
    //    temp += a[j];
    //    if (temp > max_sum) {
    //      max_sum = temp;
    //      min_index = i;
    //      max_index = j;
    //    }
    //  }
    //}

   // Прочитал про алгоритм Кадане O(n)

   // проверка на все отрицательные
  int max_element = a[0];
  for (int i = 1; i < a.size(); ++i) {
    if (a[i] > max_element) {
      max_element = a[i];
      if (max_element <= 0) {
        min_index = i;
        max_index = i;
      }
    }
  }
  if (max_element <= 0) {
    max_sum = max_element;

  }
  else {
    int temp = 0;
    for (int i = 0; i < a.size(); ++i) {
      temp += a[i];
      if (temp <= 0) {
        temp = 0;
        min_index = i + 1;
      }
      if (temp > max_sum) {
        max_sum = temp;
        max_index = i;
      }
    }
  }


  std::cout << "\n" << max_sum << "\n";
  std::cout << "\n" << min_index << "\t" << max_index << "\n";
}



/*Что нужно сделать:
Вам даётся массив целых чисел и одно число — результат.
Необходимо найти в массиве два числа, сумма которых будет давать результат,
и вывести их на экран. Гарантируется, что только одна пара чисел в массиве даёт
в сумме результат.
Пример:
a = {2, 7, 11, 15}. Результат = 9
2 + 7 = 9, так что надо вывести числа 2 и 7

Советы и рекомендации:
Как только найдена первая удовлетворяющая условиям пара, можно заканчивать поиск.

*/

void task7_2() {
  std::vector<int> a = { 2, 7, 11, 15 };
  int result = 9;
  bool find = false;
  for (int i = 0; i < a.size(); ++i) {
    int temp = a[i];
    for (int j = 1; j < a.size(); ++j) {
      if (result - a[i] - a[j] == 0) {
        std::cout << a[i] << " " << a[j] << "\n";
        find = true;
      }
      if (find) break;
    }
  }
}

/*Задача 3
Что нужно сделать:
С клавиатуры вводятся числа. Когда пользователь вводит «-1»,
необходимо выводить на экран пятое по возрастанию число среди введённых.
Когда пользователь вводит «-2», программа завершает работу.

Пример:
ввод: 7 5 3 1 2 4 6 -1
вывод: 5 (в отсортированном виде массив выглядит так: {1,2,3,4,5,6,7})
ввод: 1 1 1 -1
вывод: 2 (в отсортированном виде массив выглядит так: {1,1,1,1,2,3,4,5,6,7})
ввод -2
завершение программы

Советы и рекомендации:
Нужно удостовериться, что можно вывести требуемое число (может быть меньше пяти чисел).

*/

void task7_3() {
  std::vector<int> v;
  v.reserve(20);
  int value = 0;

  for (int i = 0; value != -2; ++i) {
    std::cin >> value;
    if (value == -1 && v.size() < 5) std::cout << "You need at least 5 digits\n";
    else if (value == -1) std::cout << v[4] << "\n";
    else {
      v.push_back(value);
      std::sort(v.begin(), v.end());
    }
  }
  std::cout << "The program is finished\n";
}

/*Задача 4
Что нужно сделать:
Вам даётся массив целых чисел, отсортированных по возрастанию.
Необходимо вывести его на экран отсортированным в порядке возрастания модуля чисел.
Пример:
Массив {-100,-50, -5, 1, 10, 15}
Вывод: 1, -5, 10, 15, -50, -100

Советы и рекомендации:
Положительные числа уже отсортированы в порядке возрастания модулей.
*/

void task7_4() {
  std::vector<int> v = { -100,-50, -5, 1, 10, 15 };
  for (int i = 0; i < v.size(); ++i) {
    for (int j = 0; j < v.size() - 1 - i; ++j) {
      if (abs(v[j]) > abs(v[j + 1])) std::swap(v[j], v[j + 1]);
    }
  }
  print_vector(v);
}

