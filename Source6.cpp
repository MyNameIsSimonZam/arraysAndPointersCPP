#include <iostream>
#include <vector>
#include <algorithm>
#include <iomanip>
#include "utils.h"


/*Задание 1. Банкетный стол
Что нужно сделать
По поводу успешного прохождения двумерных массивов собирается банкет,
организуется стол на 12 персон. Есть два VIP-места, они рядом во главе стола.
Стол протяжён в длину, места расположены в два ряда.
Каждый пришедший должен быть «упакован» соответствующим образом.

Во-первых, столовые приборы: по три на каждого человека (вилка, ложка, нож)
и одна маленькая дополнительная ложечка для VIP-персон (для десерта).
Во-вторых, тарелки: каждому по две (для первого и второго блюда)
и ещё одна тарелка для VIP-персон (для десерта).
В-третьих, стулья: минимум один для каждого гостя.

Заведите соответствующие двумерные массивы
для количества приборов, посуды и стульев и проинициализируйте их.

Но это ещё не всё. На банкете после инициализации происходят некоторые события.
Пришедшая на пятое место первого ряда дама привела с собой ребёнка,
и поэтому на данное место был приставлен ещё один стул.
С третьего места во втором ряду в неизвестном направлении была украдена ложка.
Одна из VIP-персон (любая) поделилась своей ложкой с тем, кто остался без ложки,
и стала есть суп десертной. За ненадобностью официант забрал
у VIP-гостя одну десертную тарелку, ведь есть десерт ложкой,
которая уже побывала уже в супе, неприлично. Больше без происшествий,
однако эти события на банкете надо отразить в инициализированных ранее массивах.

Советы и рекомендации
• Все действия в задаче оформляются в виде выражений внутри исходного кода.
Текстовый интерфейс для задачи делать необязательно.

• Необходимо объявить несколько двумерных массивов (по типам приборов).

• Массивы очень удобно инициализировать сразу при объявлении так:
int packages[2][3] = {
{2, 1, 7},
{3, 5, 31}
}
• Проще будет сначала записать в массивы значения из задания,
а потом отнимать или прибавлять нужные элементы, следуя за сценарием событий:
packages[0][0] +=1; // packages[0][0] хранит в себе цифру 2,
и мы прибавляем к этому значению 1 — += 1.

Что оценивается
Все действия внутри массива соответствуют условию.*/

void task6_1() {
  int forks[2][6] = {
    {3,3,3,3,3,3},
    {3,3,3,3,3,3} };
  int spoons[2][6] = {
    {4,3,3,3,3,3},
    {4,3,3,3,3,3} };
  int plates[2][6] = {
    {3,2,2,2,2,2},
    {3,2,2,2,2,2} };
  int chairs[2][6] = {
    {1,1,1,1,1,1},
    {1,1,1,1,1,1} };

  chairs[0][4] += 1;
  spoons[1][2] -= 1;
  spoons[1][0] -= 1;
  spoons[1][2] += 1;
  plates[1][0] -= 1;


  std::cout << "Forks are: " << "\n";
  for (int i = 0; i < 2; ++i) {
    for (int j = 0; j < 6; ++j) {
      std::cout << forks[i][j] << " ";
    }
    std::cout << "\n";
  }

  std::cout << "Spoons are: " << "\n";
  for (int i = 0; i < 2; ++i) {
    for (int j = 0; j < 6; ++j) {
      std::cout << spoons[i][j] << " ";
    }
    std::cout << "\n";
  }

  std::cout << "Plates are: " << "\n";
  for (int i = 0; i < 2; ++i) {
    for (int j = 0; j < 6; ++j) {
      std::cout << plates[i][j] << " ";
    }
    std::cout << "\n";
  }
  std::cout << "Chairs are: " << "\n";
  for (int i = 0; i < 2; ++i) {
    for (int j = 0; j < 6; ++j) {
      std::cout << chairs[i][j] << " ";
    }
    std::cout << "\n";
  }
};

/*Задание 2. Крестики-нолики
Что нужно сделать
Старая добрая игра на страницах всех школьных тетрадей.
Поле размером 3 × 3 представлено в виде двумерного массива с типом элементов char.
Участвуют два игрока, они ходят по очереди и ставят в указанные ими
в стандартном вводе координаты свой символ — X или O (буквы латинского алфавита).
Как только у одного из игроков будет установлено подряд три крестика или три нолика,
он побеждает. Если свободных клеток не осталось, а трёх совпадающих элементов не найдено,
то объявляется ничья. Для простоты не будем рассматривать диагональные совпадения —
только строго вертикальные и строго горизонтальные.
Изначально всё поле инициализируется символом пробела — ‘ ‘(для обозначения
пробела кавычки одинарные и в одну сторону).
Это можно сделать сразу при объявлении либо с помощью вложенного цикла.
На каждом ходе при занятой клетке или при неверных координатах этой клетки
должно быть выведено сообщение, и игрок должен указать координаты клетки повторно.
После каждого хода надо выводить в консоль текущее состояние всего игрового поля
для наглядности.

Советы и рекомендации
• Действия для обоих игроков одинаковые, отличаются только символом, который ставится на поле.
• Игровой цикл не должен быть бесконечным. Игра имеет определённое максимальное количество шагов.
• Не забывайте про случай ничьей.
• Как и в предыдущем задании, здесь будет удобно сразу заполнить массив значениями false.
Количество мест, доступных для заполнения, заранее известно.
В процессе заполнения из этой переменой нужно не забывать вычитать единицу.
Чтобы отметить место как занятое, нужно лишь написать places[i][j] = true;.
• Проверку на победу игрока, которую надо осуществлять после каждого хода,
можно сделать с помощью вложенного цикла, сразу проверяя и вертикаль, и горизонталь,
а как именно — попробуйте догадаться сами.
• Здесь заранее известно число ходов — 3 * 3. Столько раз должен быть выполнен цикл,
который спрашивает у очередного игрока координаты.
• Символ, который будет установлен в указанных координатах, можно на каждом шаге менять
подобным образом:

if (gamer_name == 'X')
gamer_name = 'O';
else
gamer_name = 'X';


Что оценивается
• Корректный ход игры, соответствующий правилам.
• Правильный (желательно красивый) вывод игрового поля.
• Понятный игроку интерфейс.*/

void print_two_dementional_3x3(char cross[3][3]) {
  for (int i = 0; i < 3; ++i) {
    for (int j = 0; j < 3; ++j) {
      std::cout << cross[i][j] << " ";
    }
    std::cout << "\n";
  }
}

int check_winner(char cross[3][3]) {
  int count_x = 0;
  int count_o = 0;

  for (int i = 0; i < 3; ++i) {
    for (int j = 0; j < 3; ++j) {
      if (cross[i][j] == 'X') ++count_x;
      if (cross[i][j] == 'O') ++count_o;
      if (count_x == 3) return 1;
      if (count_o == 3) return 2;
    }
    count_x = 0;
    count_o = 0;
  }

  for (int i = 0; i < 3; ++i) {
    for (int j = 0; j < 3; ++j) {
      if (cross[j][i] == 'X') ++count_x;
      if (cross[j][i] == 'O') ++count_o;
      if (count_x == 3) return 1;
      if (count_o == 3) return 2;
    }
    count_x = 0;
    count_o = 0;
  }

  return 0;
}

void task6_2() {
  char cross[3][3] = { {' ', ' ', ' '}, {' ', ' ', ' '}, {' ', ' ', ' '} };
  char check_repeat = 'O';
  char new_symbol;
  bool exit = false;

  for (int i = 0; i < 9; ++i) {
    int x, y;
    std::cout << "Enter horisontal coordinate\n";
    std::cin >> x;
    std::cout << "Enter vertical coordinate\n";
    std::cin >> y;
    std::cout << "Enter 'X' or 'O'\n";
    std::cin >> new_symbol;

    if (cross[x][y] != ' ') {
      std::cout << "it's filled\n";
      exit = true; break;
    }
    else cross[x][y] = new_symbol;

    if (cross[x][y] == check_repeat) {
      std::cout << "Step has not to be repeated \"X\" or \"O\" and first step has to be \"X\" only\n";
      exit = true;
    }
    else if (cross[x][y] != 'X' && cross[x][y] != 'O') {
      std::cout << "step has to be \"X\" or \"O\"\n";
      exit = true;
    }
    else if (x < 0 || x > 2 || y < 0 || y > 2) {
      std::cout << "coordinate has to be from 0 to 2\n";
      exit = true;
    }
    if (exit) break;

    else {
      if (check_winner(cross) == 1) {
        std::cout << "X win";
        exit = true;
      }
      if (check_winner(cross) == 2) {
        std::cout << "O win";
        exit = true;
      }
      check_repeat = cross[x][y];
    }
    if (exit) break;

    print_two_dementional_3x3(cross);
  }

  if (check_winner(cross) == 0) {
    std::cout << "\n" << "Nobody win";
  }
}

/*Задание 3. Матрицы
Требуется реализовать небольшую программу для сравнения двух двумерных матриц
размером 4 × 4 на предмет их полного равенства. Если матрицы равны друг другу,
необходимо взять одну из матриц и привести её к диагональному виду.
Программа принимает на вход две целочисленные матрицы A и B, которые вводятся
с помощью std::cin, и сравнивает их на предмет полного равенства.
Если матрицы равны, то об этом сообщается в стандартном выводе.
Алгоритм должен быть по возможности оптимальным и не проводить лишних операций.
Если матрицы не равны, выводится соответствующее сообщение и выполнение программы прекращается.
Если матрицы равны, то из них выбирается одна и преобразуется в диагональную.
Конвертация в диагональную форму делается путём простейшего зануления всех элементов,
лежащих вне главной диагонали. Напомню, что диагональная матрица — это такая матрица,
у которой все элементы вне диагонали равны нулю. Диагональ матрицы, в свою очередь, —
это все элементы, расположенные по диагонали от первого элемента первой строки
до последнего элемента последней строки. Итоговую диагональную матрицу можно расположить
на месте прежней матрицы, не используя дополнительных переменных.
Результат преобразования требуется вывести в консоль для проверки.
Ищите именно оптимальное решение, оно довольно простое.

Советы и рекомендации
• Чтобы не производить лишних вычислений, стоит при первом же расхождении значений
в соответствующих ячейках завершить алгоритм.
• Если хотя бы один элемент матриц не совпадает, можно сразу останавливать проверку.
• Чтобы в результате получить диагональную матрицу, достаточно пройти
по каждому элементу массива и занулить его, если строка не равна столбцу.
• Достаточно привести матрицу к диагональному виду.
Делать алгоритмическое преобразование не нужно.
• Сравнение матриц и приведение матрицы к диагональному виду лучше оформить
в виде отдельных функций.

Что оценивается
Программа корректно сравнивает две матрицы и в случае совпадения формирует диагональную матрицу.*/

void fill_two_demensional_4x4(int a[][4]) {
  for (int i = 0; i < 4; ++i) {
    for (int j = 0; j < 4; ++j) {
      std::cin >> a[i][j];
    }
  }
}

bool compare_matrix_4x4(int a[][4], int b[][4]) {
  for (int i = 0; i < 4; ++i) {
    for (int j = 0; j < 4; ++j) {
      if (a[i][j] != b[i][j]) return false;
    }
  }
  return true;
}

void print_two_dementional_4x4(int cross[][4]) {
  for (int i = 0; i < 4; ++i) {
    for (int j = 0; j < 4; ++j) {
      std::cout << cross[i][j] << " ";
    }
    std::cout << "\n";
  }
}

void task6_3() {
  int first[4][4];
  int second[4][4];

  fill_two_demensional_4x4(first);
  fill_two_demensional_4x4(second);

  if (!compare_matrix_4x4(first, second)) std::cout << "Matrices aren't equal\n";
  else {
    for (int i = 0; i < 4; ++i) {
      for (int j = 0; j < 4; ++j) {
        if (i != j) first[i][j] = 0;
      }
    }
  }

  print_two_dementional_4x4(first);
}

/*Задание 4. Умножение матрицы на вектор
Реализуйте частный случай умножения матрицы на матрицу, а именно умножение вектора на матрицу.
Эта операция распространена в компьютерной индустрии в целом и в компьютерной графике в частности,
поэтому это будет хорошим упражнением.
Итак, у нас есть четырёхкомпонентный вектор b, представленный с помощью массива,
и матрица a размером 4 × 4, представленная в виде двумерного массива.
Их произведением будет новый четырёхэлементный вектор c.
Его компоненты будут суммой произведений элемента вектора b на строку матрицы a.
Индекс столбца при этом равен индексу соответствующей компоненты вектора b,
который мы и рассчитываем.
Все входные данные, матрица a и вектор b вносятся из пользовательского ввода.
Итоговый вектор c надо вывести в консоль (std::cout). Тип данных элементов — всегда float.
Желательно реализовать этот алгоритм с помощью вложенного цикла на умножение колонки.

Советы и рекомендации
Во внутреннем цикле потребуется аккумулятор, накапливающий значение очередной ячейки
результирующего вектора. Каждый раз не забывайте его обнулять до начала расчётов.

Что оценивается
Программа вычисляет результирующий вектор в соответствии с формулой перемножения матрицы на вектор.

*/

void task6_4() {
  std::vector<float> b(4);
  std::vector<std::vector<float>> a(4, std::vector<float>(4));
  std::vector<float> c(4);

  fill_vector(b);
  fill_vector_two_demensional(a);

  for (int i = 0; i < b.size(); ++i) {
    float sum = 0;
    for (int j = 0; j < a.size(); ++j) {
      sum += b[j] * a[i][j];
    }
    c[i] = sum;
  }

  print_vector(c);

};

/*Задание 5. Пупырка
После посылки из Китая осталась спецплёнка для бережной перевозки груза — пупырка.
Всего в пупырке 12 на 12 шариков-пузырьков. Состояние любого пузырька: он либо целый,
либо нет, то есть true или false (тип массива — bool).
Для начала требуется реализовать отдельную функцию инициализации пупырки начальным состоянием:
полностью целая пупырка, все элементы true.
Программа заключается в последовательном лопании целых регионов пузырьков.
Перед каждым таким лопанием надо показывать пользователю полностью всю плёнку:
o — это целый пузырёк, x — лопнутый. Это тоже надо выделить в отдельную функцию.
Итак, как выглядит само лопание. Пользователь вводит две координаты:
начала региона и конца региона. Процедура лопания пузырей должна быть реализована
с помощью отдельной функции, все аргументы должны проверяться на валидность,
что они в в рамках диапазона возможных значений, иначе должна быть выведена ошибка.
После лопания каждого пузыря, который не был ещё лопнут до того,
в консоль должно выводиться сообщение “Pop!”.
Лопание должно продолжаться до последнего пузырька. Как только вся пупырка потрачена,
программа заканчивает выполнение. Вы можете подсчитать окончание в самой функции
по отображению пузырьков плёнки, так как функция выполняется после каждого лопания.

Советы и рекомендации
• Обратите внимание, что лопание пузырей делается с помощью региона, а не одной точки.
• Регион задаётся двумя координатами, это координаты углов прямоугольника.
• При лопании региона достаточно запустить цикл только по этим элементам.
Не нужно проходить каждый раз по всей матрице.
• Всю область плёнки удобно представить в виде двумерного массива типа bool.
• Инициализировать вручную такой массив сложно, лучше воспользоваться вложенными циклами.
• Для проверки на целостность одной ячейки (если вы используете тип bool)
можно не сравнивать её с истиной, а указать в условии имя переменной.
Например, вместо:

if (shell[i][i] == true)
{
…
}

Достаточно записать:

if (shell[i][i])
{
…
}

Такой трюк можно проделывать с переменными типа bool.

Что оценивается
• Программа заканчивает выполнение только после того, как не осталось целых пузырей.
• Лопание пузырей производится с помощью прямоугольной области.

*/

void task6_5() {
  std::vector<std::vector<bool>> a(12, std::vector<bool>(12, true));
};

/*6. Проход змейкой (дополнительное задание)
Есть двумерный массив целых чисел размером 5 на 5 элементов.
Его надо инициализировать и отобразить на экране. Особенность именно в способе этой инициализации.
Элементы должны быть инициализированы не последовательно, а змейкой:
в конце каждой строки мы должны не переходить к первому элементу следующей строки,
а начать наоборот, с последнего элемента и так далее.
В конечном отображении массива числа должны быть упорядочены по возрастанию,
но змеевидно от строке к строке. Сама же последовательность чисел — это простое
линейное возрастание от 0 до 24, для её учёта можно завести отдельную переменную.
Попытайтесь решить эту задачу используя минимальное количество временных переменных
и без условных переходов if. Если вы найдёте формулу индексации, будет замечательно!
Она может быть весьма витиеватой..

Советы и рекомендации
Результирующий массив должен выглядеть так:

0 1 2 3 4
9 8 7 6 5
10 11 12 13 14
19 18 17 16 15
20 21 22 23 24

Внешний и внутренний циклы идут от 0 до 5, тут ничего нового.
Первый индекс (строка) тоже без сюрпризов: это значение счётчика внешнего цикла:

for (int i = 0; i < 5; ++i) {
for (int i = 0; i < 5; ++i) {
digits[i][...] = number;
number += 1;
}
…
}

Самое сложное тут — это номер столбца. Чтобы сначала двигаться слева направо,
а на следующей строке наоборот, стоит завести переменную-множитель,
которая на чётных строках будет равна 1. На нечётных строках меняет знак: multiplier *= −1;

Что оценивается
В решении не используются условные конструкции.

*/

void task6_6() {

};

/*Задание 7. Почти «Майнкрафт» (дополнительное задание)
Нам предстоит сделать некое подобие «Майнкрафта».
Миллионов не обещаю, но это интересная задача на пространственное мышление.
У нас есть небольшой квадратный ландшафт, размером 5 × 5 секторов.
В каждом секторе располагается блок (столбик) ландшафта,
максимальная высота которого — 10 блоков.
Текущая высота каждого такого блока задаётся пользователем в начале программы.
Итоговая задача: используя трёхмерный массив, вывести в стандартный вывод
горизонтальное сечение (или горизонтальный срез) нашего небольшого мира.
Сам мир как раз должен быть представлен в виде трёхмерного массива.
Его горизонтальный срез — это двумерный массив, который надо отобразить в виде единиц и нулей.
0 — это отсутствие элемента на данном уровне в данной точке, 1 — элемент есть.
Уровень среза от 0 до 9 включительно также задаётся в стандартном вводе.

Пример выполнения

input matrix of heights:
5 5 5 5
4 4 4 4
3 2 2 3
1 1 1 1
input slice: 4
1 1 1 1
1 1 1 1
0 0 0 0
0 0 0 0
input slice: 3
1 1 1 1
1 1 1 1
1 0 0 1
0 0 0 0

Пояснение к примеру


Что оценивается
• Использован трёхмерный массив.
• Пользователь задаёт срез ландшафта, который хочет увидеть (от 0 до 9).
• Выводится срез размером 5 × 5, состоящий из 0 и 1.

Советы и рекомендации
При печати потребуется проверять содержимое трёхмерного массива.
При уже известном значении уровня level проверка выглядит так:

if (world[i][i][level])
{
//печатаем 1
}
else
{
//печатаем 0
}
*/

void task6_7() {

};

/*8. Морской бой (дополнительное задание)
Требуется реализовать упрощённую игру в морской бой.
Игровое поле размером 10 на 10 клеток. Участвуют два игрока.
В арсенале каждого из них 4 маленьких кораблика размером в одну клетку,
3 небольших корабля размером в две клетки, 2 средних корабля размером в три клетки
и один большой корабль размером в четыре клетки.
Для простоты клетки поля пронумерованы по вертикали от 0 до 9 и по горизонтали от 0 до 9.
Мы не будем использовать классические наименования клеток, такие как B4, C6,
а просто два индекса. Вначале игроки по очереди расставляют корабли,
начиная с самых маленьких и заканчивая большими.
Маленькие корабли в одну клетку расставляются с помощью указания одной клетки-точки на поле,
к примеру 2,1. Корабли размерностью от двух клеток и выше расставляются
с помощью координат их начала и конца, к примеру: 0,1–0,3.
Корабли могут быть установлены только строго вертикально или горизонтально.
Установка корабля по диагонали недопустима, об этом тоже надо сообщить пользователю.
Если корабль не может быть размещён на заданных клетках из-за того,
что он столкнётся с другим кораблём (окажется на его клетках) или выйдет за пределы поля,
то игроку должно быть сделано предупреждение, после которого он должен переставить корабль
на новые валидные координаты. В нашем упрощённом варианте игры мы не будем обсчитывать
соприкосновения кораблей друг с другом, а потому корабли вполне можно будет размещать
друг к другу вплотную, борт к борту. После того как все корабли расставлены, начинается игра.
Игроки по очереди атакуют друг друга, называя координаты выстрела.
После выстрела в консоль выводится информация о его результате: попал или мимо.
Если выстрел успешен, клетка, на которой был корабль (или его фрагмент),
затирается и становится пустой. Игра заканчивается тогда,
когда все корабли одной из сторон будут полностью уничтожены.
Как только это произойдёт, в консоль выводится информация с номером игрока, который победил.

Советы и рекомендации
Действия игроков практически одинаковые, их можно объединить в функции.
В программе достаточно иметь два поля, по одному на каждого игрока.
Лучше создать три отдельные функции: одну для размещения одного корабля,
еще одну как обёртку над первой (она будет размещать все корабли),
а третью для удара по координате.
Также вам потребуются два глобальных массива для двух отдельных участков моря:

bool field_1[10][10];
bool field_2[10][10];

Что оценивается
• Корабли расставляются правильно.
• Есть возможность выиграть.
• Реализован понятный и удобный для пользователя интерфейс игры.
*/

void task6_8() {

};