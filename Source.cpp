#include <iostream>
#include <string>
#include <cassert>
#include <set>

/*Задание 1. Многоквартирный дом

Что нужно сделать:
На вход программе поступают десять фамилий в формате строк.
Это фамилии жильцов квартир с первой по десятую.
Необходимо прочитать эти фамилии и записать в одномерный массив.
Далее пользователь вводит три номера квартир.
Необходимо вывести в консоль фамилию жильца, проживающего в этой квартире.
Если пользователь введёт некорректный номер квартиры, необходимо сообщить ему об этом.

Пример:

← SidorovA
← IvanovA
← PetrovA
← SidorovB
← IvanovB
← vPetrovB
← SidorovC
← IvanovC
← PetrovC
← SidorovD
←10
→SidorovD
←1
→SidorovA
←5
→IvanovB

Что оценивается:
• Используется массив строк для хранения данных.
• В коде не используются библиотеки, кроме <iostream> и <string>.
• Программа проверяет доступность элемента по индексу и выдаёт корректный результат.
*/

void task1() {
  std::string arrLastName[10];
  int flat;

  arrLastName[0] = "SidorovA";
  arrLastName[1] = "IvanovA";
  arrLastName[2] = "PetrovA";
  arrLastName[3] = "SidorovB";
  arrLastName[4] = "IvanovB";
  arrLastName[5] = "PetrovB";
  arrLastName[6] = "SidorovC";
  arrLastName[7] = "IvanovC";
  arrLastName[8] = "PetrovC";
  arrLastName[9] = "SidorovD";

  std::cout << "Enter a apartment number (from 1 to 10): ";
  std::cin >> flat;
  if (flat < 1 || flat > 10) std::cout << "Error... From 1 to 10 only... \n";
  else {
    std::string answer = arrLastName[flat - 1];
    std::cout << answer;
  }
}

/*Задание 2. Сортировка

Что нужно сделать:
Пользователь вводит в консоль 15 дробных чисел.
Необходимо прочитать их и вывести в консоль в порядке от большего к меньшему.
По возможности используйте минимум дополнительной памяти и проходов по массиву.

Пример:

Ввод: 1.2 2.3 1.11 3.4 5.5 5.4 5.3 5.1 1.5 1.25 5.41 5.31 5.11 1.51 1.251
Вывод: 5.5 5.41 5.4 5.31 5.3 5.11 5.1 3.4 2.3 1.51 1.5 1.251 1.25 1.2 1.11

Что оценивается:
• Используется массив чисел с плавающей точкой для хранения данных.
• В коде не используются библиотеки, кроме <iostream>.
• Программа корректно использует обращения по индексам и выдаёт правильный ответ.
• Асимптотическая сложность алгоритма не более O(n^2).
• Числа выводятся от большего к меньшему.*/

void task2() {
  const int kArraySize = 15;
  float array[] = { 1.2, 2.3, 1.11, 3.4, 5.5, 5.4, 5.3, 5.1, 1.5, 1.25, 5.41, 5.31, 5.11, 1.51, 1.251 };
  for (int i = 0; i < kArraySize - 1; ++i)
  {
    for (int j = 0; j < kArraySize - 1; ++j) {
      float temp;
      if (array[j] < array[j + 1]) {
        temp = array[j];
        array[j] = array[j + 1];
        array[j + 1] = temp;
      }
    }
  }
  for (int i = 0; i < kArraySize; ++i) {
    std::cout << array[i] << " ";
  }
};

/*Задание 3. Использование assert
Что нужно сделать:
Создайте в своей программе функцию float travelTime(float distance, float speed).
Она будет находить время в пути и при этом использовать assert,
чтобы отбросить нулевую и отрицательную скорость.
Вызовите эту функцию в main. Убедитесь, что падение происходит за счёт assert.
Не забудьте подключить заголовочный файл cassert.

Что оценивается:
При запуске происходит падение с указанием исходника и строки в нём, на которой расположен вызов макроса assert.
*/

void task3() {
  auto travel_time = [](float distance, float speed) {
    assert(distance >= 0 && speed > 0);
    return distance / speed;
    };
  float distance = 100.f, speed = 10.1f;
  std::cout << travel_time(distance, speed) << "\n";
};

/*Задание 4. Ряд чисел* (дополнительное задание)

Что нужно сделать:
В программе инициализирован массив из 15 целых положительных чисел.
Эти числа являются множеством из 14 последовательных чисел, начиная с Х (Х может быть любым),
а одно число из ряда повторяется. Необходимо найти повторяющееся число и вывести его в консоль.
По возможности используйте минимум дополнительной памяти и проходов по массиву.

Пример:

int numbers[15] = {114, 111, 106, 107, 108, 105, 115, 108, 110, 109, 112, 113, 116, 117, 118}
В данном примере Х — это 105, а повторяющееся число — 108.


Рекомендации по выполнению
Это задание с подвохом. Подумайте, как его можно было бы легко решить за O(n).

Что оценивается:
Используется массив int для хранения данных.
В коде не используются библиотеки, кроме <iostream>.
Программа корректно использует обращения по индексам и выдаёт правильный ответ.
Асимптотическая сложность алгоритма менее O(n^2).*/

//void task4() {         // Insertion sort
//  const int kArraySize = 15;
//  int array[] = { 114, 111, 106, 107, 108, 105, 115, 108, 110, 109, 112, 113, 116, 117, 118 };
//  int double_int;
//
//  for (int i = 1; i < kArraySize; ++i) {
//    int temp = array[i];
//    int j = i - 1;
//    while (j >= 0 && array[j] < temp) {
//      array[j + 1] = array[j];
//      --j;
//    }
//    array[j + 1] = temp;
//  }
//
//  for (int i = 0; i < kArraySize - 1; ++i) {
//    if (array[i] == array[i + 1]) std::cout << array[i] << "\n";
//  }
//};


void task4() {
  const int kArraySize = 15;
  int array[] = { 114, 111, 106, 107, 108, 105, 115, 108, 110, 109, 112, 113, 116, 117, 118 };
  //int double_int;

  int sum = 0;
  for (int i = 0; i < kArraySize; ++i) {
    sum += array[i];
  }
  std::cout << sum << "\n";
  //std::cout << double_int << "\n";
        // ИЩЕМ МИНИМАЛЬНОЕ ЗНАЧЕНИЕ И СЧИТАЕМ ПРОГРЕССИЮБ ПОТОМ ИЗ СУММЫ ВСЕХ ЧИСЕЛ ВЫЧИТАЕМ СУММЫ ПОСЛЕДОВАТЕЛЬНЫХ ЧИСЕЛ
};









